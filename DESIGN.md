# Design Documentation - Legends of Valor

This project implements two RPG game variants - "Monsters & Legends" (a classic dungeon exploration game) and "Legends of Valor" (a strategic tower defense game) - using a shared object-oriented framework that demonstrates key design patterns and principles.

**Architecture and Class Structure**
The architecture follows a layered design with five main packages: entities (character hierarchy), items (equipment and inventory system), board (game world representation), game (game logic and controllers), and common/utils (shared utilities). The entities layer defines the character inheritance hierarchy with `RPGCharacter` as the abstract base class, extended by `Hero` and `Monster` with specific hero types (`Warrior`, `Paladin`, `Sorcerer`) as concrete implementations. The items layer implements an inventory system with `Item` as the abstract base class extended by `Weapon`, `Armor`, `Spell`, and `Potion`. The board layer provides flexible grid representation through `Board`, `Cell`, and specialized board implementations (`LegendsBoard`, `ValorBoard`) with different cell types defined by the `CellType` enum. The game layer contains the core game logic with `Game` as the abstract template method pattern implementation, extended by `LegendsGame` and `ValorGame`, supported by controllers like `BattleController` and `MarketController`.

**Inheritance Hierarchies and Design Patterns**
The project demonstrates several key inheritance hierarchies that showcase object-oriented design principles. The character hierarchy uses `RPGCharacter` as the abstract base class containing common attributes (HP, mana, stats) and behaviors (combat, leveling), with `Hero` and `Monster` as intermediate abstract classes adding role-specific functionality, and concrete hero classes (`Warrior`, `Paladin`, `Sorcerer`) implementing class-specific stat bonuses and abilities. The items hierarchy follows a similar pattern with `Item` as the abstract base containing common properties (name, price, level requirements), and specialized subclasses (`Weapon`, `Armor`, `Spell`, `Potion`) implementing type-specific behaviors like damage calculation and stat modification.

The framework implements the Template Method pattern through the abstract `Game` class, which defines the game loop structure (`startGame()`, `playTurn()`, `checkWinCondition()`) while allowing concrete game implementations to customize specific behaviors. The Strategy pattern is used in combat mechanics, where different spell types and character abilities are implemented as polymorphic behaviors. The Factory pattern appears in the `GameDataLoader` class for creating game objects from configuration files.

**Scalability and Extensibility for RPG Games**
The framework was designed to make adding new RPG game modes straightforward by following common RPG patterns: character creation, turn-based gameplay, inventory management, and progression systems. The abstract `Game` class captures the core RPG loop through template methods that each game variant extends. To add a new RPG game mode, you extend `Game` to define your specific rules and victory conditions, create a specialized `Board` subclass if needed for unique terrain features, and implement any new item types or character abilities by extending the existing hierarchies.

The polymorphic design allows for easy extension - new hero classes can be added by extending `Hero` and implementing class-specific bonuses, new item types can be created by extending `Item`, and new game mechanics can be integrated through the controller pattern. This separation of concerns between game rules, character mechanics, and board representation makes the framework both scalable and maintainable.

**Type Safety and Generics**
The project uses generics strategically to ensure type safety while maintaining flexibility. The `Inventory` class uses generic collections (`List<Item>`) with type-specific getter methods (`getWeapons()`, `getArmor()`, `getSpells()`, `getPotions()`) that return appropriately typed lists through runtime type checking and casting. The board system uses generic cell types, allowing different games to store different types of game objects while maintaining type safety for access operations.

Method signatures use generic wildcards and bounded type parameters where appropriate to ensure compile-time type safety. For example, inventory operations are type-safe through method overloading and runtime type checking, preventing ClassCastException errors while maintaining clean APIs. The character hierarchy uses polymorphism extensively, allowing different hero types and monsters to be treated uniformly in collections while preserving type-specific behaviors through method overriding.

**Object-Oriented Design Principles**
The design demonstrates key OOP principles throughout the codebase. Encapsulation is maintained through private fields with controlled access via getters and setters, particularly in character stats and inventory management. Inheritance is used appropriately for "is-a" relationships (Hero is-a RPGCharacter, Weapon is-a Item) while composition handles "has-a" relationships (Hero has-a Inventory, Party has-a List of Heroes).

Polymorphism enables uniform treatment of different character types and items through their base class interfaces, allowing the same combat and inventory code to work with all character and item variants. Abstraction is achieved through abstract base classes that define contracts for subclasses while hiding implementation details. The `RPGCharacter` abstract class, for example, defines the combat interface without specifying how different character types calculate damage or apply abilities.

**Game-Specific Implementations**
The two game variants showcase how the framework supports different gameplay mechanics while sharing core systems. "Monsters & Legends" implements classic dungeon exploration with random encounters, market interactions, and turn-based party management. "Legends of Valor" adds strategic elements with lane-based movement, tower defense mechanics, and real-time-style combat where heroes and monsters move simultaneously across a structured battlefield.

Both games share the underlying character progression, inventory management, and combat systems, but implement different win conditions, movement rules, and interaction patterns. This demonstrates the framework's flexibility - core RPG mechanics remain consistent while game-specific rules are cleanly separated into their respective game classes.

**Development Outcome**
The development successfully created a flexible RPG framework supporting multiple game variants with clean separation of concerns. The inheritance hierarchies provide clear type relationships while enabling polymorphic behavior, the template method pattern ensures consistent game flow while allowing customization, and the modular design makes adding new content straightforward. The framework balances abstraction with concrete implementation, providing enough structure to ensure consistency while maintaining flexibility for different game mechanics.