# Design Documentation - Legends of Valor

This project implements two RPG game variants - "Monsters & Legends" (a classic dungeon exploration game) and "Legends of Valor" (a strategic tower defense game) - using a shared object-oriented framework that demonstrates key design patterns and principles.

**Architecture and Class Structure**
We organized the system into five layers that keep everything neat and organized: entities handle the character hierarchy, items manage equipment and inventory, board represents the game world, game contains the core logic and controllers, and common/utils has shared utilities. The whole design revolves around two main inheritance hierarchies and several key design patterns that make the framework flexible. Each layer has its own job with clean interfaces between them, and we use controllers to manage how different parts of the system talk to each other.

**Inheritance Hierarchies and Design Patterns**

We built two main hierarchies that make everything work smoothly. For characters, we start with `RPGCharacter` as the base that holds all the shared stuff like health and combat behavior, then `Hero` and `Monster` add their own special features, and concrete classes like `Warrior`, `Paladin`, and `Sorcerer` implement their unique abilities. The items work the same way with `Item` as the foundation, then `Weapon`, `Armor`, `Spell`, and `Potion` each doing their own thing. Heroes can get temporary battle boosts that wear off after fights, and we made equipment realistic by having weapons degrade each round you use them and armor wear down with every hit you take.

For design patterns, we use Template Method in the `Game` class to set up the basic game loop structure with `startGame()`, `playTurn()`, and `checkWinCondition()`, but `LegendsGame` and `ValorGame` can customize how movement and winning actually work. The Strategy pattern handles all the different combat mechanics - different spells do different things, character abilities work differently, and boost systems can be mixed and matched. We use Factory pattern in `GameDataLoader` to create all our objects from config files, which handles all the tricky setup and inheritance stuff automatically.

We also threw in some other useful patterns. Observer pattern handles events like when equipment breaks down or battles start and end, so the UI knows to update. Composite pattern in the `Party` class means we can treat individual heroes and whole groups the same way, which makes party management much simpler. Throughout everything, we use polymorphism so the same combat and inventory code works with all the different character types and items while still letting each one behave uniquely.

**Scalability and Extensibility for Games**
Adding new content is pretty straightforward - you can extend the `Game` class to create completely different game variants, add new character classes by extending `Hero`, or create new equipment types by extending `Item`. The market system automatically adjusts inventory based on your party's highest level, so players always see appropriate items. We built in support for equipment durability and battle boost mechanics that any new game can use. The modular design means you just follow the existing patterns when adding content, and if you need special terrain features, you can extend the board system with specialized subclasses.

**Type Safety and Generics**
We use generic collections with type-specific getters so you never get those annoying ClassCastException errors that crash your game. Runtime type checking keeps our APIs clean and predictable. The `Inventory` class uses `List<Item>` but has handy methods like `getWeapons()` that give you back exactly the right type of list. We also use bounded type parameters in method signatures when it makes sense to catch problems at compile time instead of runtime.

**Object-Oriented Design Principles**
We keep things encapsulated with private fields so nothing gets messed with accidentally, use inheritance for "is-a" relationships like how a Warrior is-a Hero, and composition for "has-a" stuff like how a Hero has-a Inventory. Polymorphism lets us treat different character types and items the same way through their base class interfaces, which is super convenient. Abstract classes set up contracts that subclasses have to follow while hiding the messy implementation details. Everything has a single, clear job, so you always know where to look when something needs fixing.

**Game-Specific Implementations**
"Monsters & Legends" is all about dungeon exploration where you never know what you'll run into next. "Legends of Valor" takes a completely different approach with lane-based tower defense gameplay. Both games share the same progression, inventory, combat, durability, and boost systems, but they implement totally different rules on top. The shared framework is flexible enough to handle different ways to win, different movement styles, and different ways players interact with the world. We kept the game-specific rules cleanly separated in their own classes while still using all the common systems underneath.

**Development Outcome**
We successfully built a flexible RPG framework that showcases multiple design patterns and inheritance hierarchies in action. The clean separation between different parts makes it easy to add new features and maintain existing code while supporting all kinds of game mechanics. We found a good balance between keeping things abstract enough to be reusable but concrete enough to actually work well. The equipment durability system, battle boosts, level-based markets, and game guides worked to make the game work even better.